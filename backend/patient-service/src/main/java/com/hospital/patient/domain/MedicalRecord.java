package com.hospital.patient.domain;

import java.time.LocalDateTime;

import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
* Medical Record Entity
*
* Represents a medical record entry for a patient.
* Contains diagnosis, treatment, and clinical notes.
*/
@Entity
@Table(name = "medical_records", indexes = {
  @Index(name = "idx_medical_record_patient", columnList = "patient_id"),
  @Index(name = "idx_medical_record_date", columnList = "record_date"),
  @Index(name = "idx_medical_record_type", columnList = "record_type")
})
@EntityListeners(AuditingEntityListener.class)
// Suppress 'unused' warnings: fields/constants are accessed via JPA/reflection or generated by Lombok;
// this keeps the Problems panel focused on real issues when annotation processing is unavailable.
@SuppressWarnings("unused")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class MedicalRecord {
    private static final int MAX_VAL_100 = 100;
    private static final int VAL_200 = 200;
    private static final int VAL_300 = 300;
    private static final int VAL_500 = 500;
    private static final int VAL_50 = 50;
    private static final int VAL_20 = 20;
    private static final int VAL_5 = 5;
    private static final int VAL_4 = 4;
    private static final int VAL_255 = 255;
    private static final int VAL_11 = 11;
  /** Id. */

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  /** Patient. */

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "patient_id", nullable = false)
  @NotNull(message = "Patient is required")
  private Patient patient;
  /** Record date. */

  @Column(name = "record_date", nullable = false)
  @NotNull(message = "Record date is required")
  private LocalDateTime recordDate;
  /** Record type. */

  @Enumerated(EnumType.STRING)
  @Column(name = "record_type", nullable = false)
  @NotNull(message = "Record type is required")
  private RecordType recordType;
  /** Chief complaint. */

  @Column(name = "chief_complaint", length = VAL_500)
  @Size(max = VAL_500, message = "Chief complaint cannot exceed 500 characters")
  private String chiefComplaint;
  /** Diagnosis. */

  @Column(name = "diagnosis", columnDefinition = "TEXT")
  private String diagnosis;
  /** Treatment. */

  @Column(name = "treatment", columnDefinition = "TEXT")
  private String treatment;
  /** Clinical notes. */

  @Column(name = "clinical_notes", columnDefinition = "TEXT")
  private String clinicalNotes;
  /** Doctor id. */

  @Column(name = "doctor_id", length = MAX_VAL_100)
  @Size(max = MAX_VAL_100, message = "Doctor ID cannot exceed MAX_VAL_100 characters")
  private String doctorId;
  /** Department. */

  @Column(name = "department", length = MAX_VAL_100)
  @Size(max = MAX_VAL_100, message = "Department cannot exceed MAX_VAL_100 characters")
  private String department;

  @Column(name = "follow_up_required")
  @Builder.Default
  private Boolean followUpRequired = false;
  /** Follow up date. */

  @Column(name = "follow_up_date")
  private LocalDateTime followUpDate;

  // Manual builder fallback for IDEs/language servers that cannot run Lombok processors
  public static MedicalRecordBuilder builderFallbackInternal() { return new MedicalRecordBuilder(); }
  // Delegate matching Lombok API
  public static MedicalRecordBuilder builder() { return builderFallbackInternal(); }

  public static class MedicalRecordBuilder {
    private Long id;
    private java.time.LocalDateTime recordDate;
    private RecordType recordType;
    private String diagnosis;
    private String treatment;
    private String clinicalNotes;
    private String doctorId;

    public MedicalRecordBuilder id(Long id) { this.id = id; return this; }
    public MedicalRecordBuilder recordDate(java.time.LocalDateTime d) { this.recordDate = d; return this; }
    public MedicalRecordBuilder recordType(RecordType t) { this.recordType = t; return this; }
    public MedicalRecordBuilder diagnosis(String d) { this.diagnosis = d; return this; }
    public MedicalRecordBuilder treatment(String t) { this.treatment = t; return this; }
    public MedicalRecordBuilder clinicalNotes(String n) { this.clinicalNotes = n; return this; }
    public MedicalRecordBuilder doctorId(String id) { this.doctorId = id; return this; }

    public MedicalRecord build() {
      MedicalRecord mr = new MedicalRecord();
      mr.id = this.id;
      mr.recordDate = this.recordDate;
      mr.recordType = this.recordType;
      mr.diagnosis = this.diagnosis;
      mr.treatment = this.treatment;
      mr.clinicalNotes = this.clinicalNotes;
      mr.doctorId = this.doctorId;
      return mr;
    }
  }

  // Audit Fields
  /** Created date. */
  @CreatedDate
  @Column(name = "created_date", nullable = false, updatable = false)
  private LocalDateTime createdDate;
  /** Last modified date. */

  @LastModifiedDate
  @Column(name = "last_modified_date")
  private LocalDateTime lastModifiedDate;
  /** Created by. */

  @Column(name = "created_by", length = MAX_VAL_100)
  private String createdBy;
  /** Last modified by. */

  @Column(name = "last_modified_by", length = MAX_VAL_100)
  private String lastModifiedBy;

  public enum RecordType {
    CONSULTATION,
    EMERGENCY,
    SURGERY,
    FOLLOW_UP,
    DISCHARGE,
    ADMISSION,
    DIAGNOSTIC,
    TREATMENT
  }
}
